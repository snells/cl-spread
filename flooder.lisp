(in-package :cl-spread)

(defvar max-messlen 100000)
(defvar mess (alloc :char max-messlen))
(defvar recv-mess (alloc :char max-messlen))
(defvar flooder-max-groups 100)
(defvar user (alloc :char 80))
(defvar spread-name (alloc :char 80))
(defvar private-group (alloc :char 32))
(defvar mbox (alloc 'mailbox))
(defvar num-bytes (alloc :int))
(defvar num-messages (alloc :int))
(defvar num-members (alloc :int))
(defvar read-only)
(defvar write-only)
(defvar ret-groups (make-c-array  :char (list flooder-max-groups 32)))
(defvar send-counter (alloc :int))
(defvar recv-counters (alloc :int flooder-max-groups))
(defvar lowest-recv-counter (alloc :int))
(defvar my-counter-index (alloc :int))

(lisp-string-to-foreign "flooder" user 79)
(lisp-string-to-foreign "4803@localhost"  spread-name 79)
(setf (ref-int num-bytes) 1000
      (ref-int num-messages) 10000
      (ref-int num-members) 0
      read-only 0
      write-only 0)
(defun main ()
  (let ((ret)
	(service-type (alloc :int))
	(num-groups (alloc :int))
	(sender (alloc :char 32))
	(mess-type (alloc :int16))
	(dummy-endian-mismatch (alloc :int))
	(joined-members (alloc :int))
	(sender-index (alloc :int)))
    (format out "flooder: connecting to ~a~%" (foreign-string-to-lisp spread-name))
    (setf ret (sp-connect spread-name user 0 0 mbox private-group))
    (when (< ret 0)
      (sp-error ret)
      (quit 1))
    (with-foreign-string (str "flooder")
      (sp-join (ref-int mbox) str))
    (format out "flooder: starting multicast of ~a messages, ~a bytes each.~%" (ref-int num-messages)
	    (ref-int num-bytes))
    (setf (ref-int joined-members) 0)
    (do ()
	((>= (ref-int joined-members) (ref-int num-members)))
      (setf (ref-int service-type) 0
	    ret (sp-receive (ref-int mbox) (ref-int service-type) sender flooder-max-groups
			    num-groups ret-groups mess-type dummy-endian-mismatch max-messlen
			    recv-mess))
      (when (< ret 0)
	(when (or (= ret +groups-too-short+) (= ret +buffer-too-short+))
	  (format out "~%\n========Buffers or Groups too Short=======~%Should NOT happen in wait for members! Program quitting~%")
	  (quit 1)))
      (let ((service-val (ref-int service-type)))
	(cond ((regular-messp service-val)
	       (setf (mem-aref mess ret) 0)
	       (format out "received ~a"
		       (cond ((unreliable-messp service-val) "UNRELIABLE ")
			     ((reliable-messp service-val) "RELIABE ")
			     ((fifo-messp service-val) "FIFO ")
			     ((causal-messp service-val) "CAUSAL ")
			     ((agreed-messp service-val) "AGREED ")
			     ((safe-messp service-val) "SAFE ")))
	       (format out "message during wait for members, from ~a, of type ~a (endian ~a) to ~a groups ~%(~a bytes): ~a~%"
		       (foreign-string-to-lisp sender) (ref-int mess-type) (ref-int dummy-endian-mismatch)
		       (ref-int num-groups) ret (foreign-string-to-lisp recv-mess)))
	      ((membership-messp service-val)
	       (cond ((reg-memb-messp service-val)
		      (format out "received REGULAR membership for group ~a with ~a members, where I am member ~a:~%"
			      (foreign-string-to-lisp sender) (ref-int num-groups) (ref-int mess-type))
		      (dotimes (i (ref-int num-groups))
			(format out "~a~a~%" #\tab (foreign-string-to-lisp (mem-aptr :pointer ret-groups i))))
		      (setf (ref-int joined-members) (ref-int num-groups)))
		     ((transition-messp service-val)
		      (format out "received TRANSITIONAL membership for group ~a~%"
			      (foreign-string-to-lisp sender)))
		     ((caused-leave-messp service-val)
		      (format out "received membership message that left group ~a~%"
			      (foreign-string-to-lisp sender)))
		     (t (format out "received inconrrectly membership message of type ~x~%"
				(ref-int service-val)))))
	      ((reject-messp service-val)
	       (format out "REJECTED message from ~a, of servicetype ~x messtype ~a, (endian ~a) to ~a groups ~%(~a bytes): ~a~%"
		       (foreign-string-to-lisp sender) service-val (ref-int mess-type)
		       (ref-int dummy-endian-mismatch) (ref-int num-groups) ret (foreign-string-to-lisp recv-mess)))
	      (t (format out "received mssage of unknown message type ~x with ret ~a~%"
			 service-val ret)))
	(when (not (zerop (ref-int num-members)))
	  (setf (ref-int my-counter-index) (ref-int mess-type))
	  (memcpy (mem-aptr mess :char) my-counter-index (foreign-type-size :int)))
	(do ((i 1 (1+ i)))
	    ((> i (ref-int num-messages)))
	  (when (zerop read-only)
	    (with-foreign-string (str "flooder")
	      (cond ((not (zerop (ref-int num-members)))
		     (setf ret (sp-multicast (ref-int mbox) +fifo-mess+ str 0 (ref-int num-bytes) mess))
		     (incf (ref-int send-counter)))
		    (t (setf ret (sp-multicast (ref-int mbox) +reliable-mess+ str 0 (ref-int num-bytes)
					       mess))))
	      (when (/= ret (ref-int num-bytes))
		(when (< ret 0)
		  (sp-error ret)
		  (quit 1))
		(format out "send a differend message ~a -> ~a~%" (ref-int num-bytes) ret))
	      (when (or (not (zerop read-only)) (and (> i 200) (zerop write-only)))
		(do ((notdone 1))
		    ((zerop notdone))
		  (setf (ref-int service-type) 0
			ret (sp-receive (ref-int mbox) service-type (foreign-string-to-lisp sender)
					flooder-max-groups num-groups ret-groups
					mess-type dummy-endian-mismatch max-messlen recv-mess))
		  (when (< ret 0)
		    (when (or (= ret +groups-too-short+) (= ret +buffer-too-short+))
		      (setf (ref-int service-type) +drop-recv+)
		      (format out "~%========Buffers or Groups too Short=======~%")
		      (setf ret (sp-receive (ref-int mbox) service-type (foreign-string-to-lisp sender)
					    flooder-max-groups num-groups ret-groups
					    mess-type dummy-endian-mismatch max-messlen recv-mess))))
		  (when (< ret 0)
		    (sp-error ret)
		    (quit 1))
		  (cond ((not (zerop (ref-int num-members)))
			 (memcpy sender-index (mem-aptr recv-mess :char 0) (foreign-type-size :int))
			 (incf (mem-aref recv-counters :int (ref-int sender-index)))
			 (when (= (mem-aref recv-counters :int (ref-int sender-index))
				  (+ (ref-int lowest-recv-counter) 1))
			   (setf (ref-int lowest-recv-counter) (ash #xffffffff -1))
			   (dotimes (j (ref-int num-members))
			     (cond ((zerop (mem-aref recv-counters :int j)))
				   ((< (mem-aref recv-counters :int j) (ref-int lowest-recv-counter))
				    (setf (ref-int lowest-recv-counter) (mem-aref recv-counters :int j)))))
			   (if (= (ref-int lowest-recv-counter) (ash #xffffffff -1))
			       (setf (ref-int lowest-recv-counter) 0)))
			 (setf notdone (if (and (zerop read-only)
						(< (ref-int lowest-recv-counter) (- (ref-int send-counter) 200))) 1 0)))
			(t (setf notdone (if (and (/= 0 (strcmp sender private-group)) (zerop read-only)) 1 0))))))
	      (if (= 0 (mod i 1000)) (format out "flooder: completed ~a messages of ~a bytes~%"
					     i ret)))))))
    (format out "flooder: completed multicast of ~a messages, ~a bytes each.~%" (ref-int num-messages)
	    (ref-int num-bytes))
    (free service-type num-groups sender mess-type dummy-endian-mismatch joined-members sender-index
	  mess recv-mess user spread-name private-group mbox num-bytes num-messages num-members ret-groups send-counter recv-counters lowest-recv-counter my-counter-index)
    0))
