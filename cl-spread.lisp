;;;; cl-spread.lisp

(in-package #:cl-spread)
(defvar out *standard-output*)
(defvar max-mess-len 102400)

(defun version ()
  (with-foreign-objects ((major :int)
			 (minor :int)
			 (patch :int))
    (sp-version major minor patch)
    (format out "~a.~a.~a~%" (ref-int major)
	    (ref-int minor)
	    (ref-int patch))))
(defun connect (host user-name &optional  (group-membership 1))
  (with-foreign-strings ((user user-name)
			 (sp host))
    (let* ((mbox (alloc :int))
	   (private-group (alloc :char +max-group-name+))
	   (code (sp-connect sp user 0 group-membership mbox private-group)))
      (print-error-msg code)
      (cond ((< code 0)
	     (free mbox private-group) nil)
	    (t (list :name user :host host :mbox mbox :private-group (foreign-string-to-lisp private-group)))))))
(defun join (con group)
  (with-foreign-string (str group)
    (let ((ret (sp-join (ref-int (getf con :mbox)) str)))
      (if (< ret 0)
	  (print-error-msg ret)))))

(defun conp-mbox (con)
  (getf con :mbox))
(defun con-mbox (con)
  (ref-int (conp-mbox con)))
(defun poll (con)
  (let ((num (if (consp con) (con-mbox con) con)))
    (if (not (zerop (sp-poll num))) t nil)))

(defun receive (con)
  (let ((groups (make-c-array :char `(16 ,+max-group-name+)))
	(res))
  (with-foreign-objects ((s-type :int)
			 (sender :char +max-group-name+)
			 (num-groups :int)
			 ;(groups :pointer 16
			 (mess-type :int16)
			 (endian :int)
			 (mess :char max-mess-len))
    (let ((ret (sp-receive (con-mbox con) s-type sender
			   16 num-groups groups
			   mess-type endian max-mess-len mess)))
      (cond ((< ret 0)
	     (print-error-msg ret))
	    (t (let ((lispy-groups '()))
		 (dotimes (x (ref-int num-groups))
		   (push (foreign-string-to-lisp (mem-aptr groups :pointer x)) lispy-groups))
		 (setf res (list (ref-int s-type) (foreign-string-to-lisp sender)
				 lispy-groups
				 (ref-int16 mess-type) (ref-int endian) ret
				 (foreign-string-to-lisp mess))))))))
  (free groups)
  res))

(defun receive-mess (con)
  (car (last (receive con))))

(defun format-mess (lst)
  (multiple-value-bind (service-type sender groups mess-type endian bytes mess)
      (apply #'values lst)
    (format out "received ~a message from ~a, of type ~a, (endian ~a) to groups ~a (~a bytes): ~a~%"
	    service-type sender mess-type endian groups bytes mess)))
(defun receive-formatted-mess (con)
  (format-mess (receive con))
  (force-output out))

(defun send (con mess group &optional (service-type +safe-mess+)
			       (mess-type +medium-priority+))
  (with-foreign-strings ((g group) (s mess))
    (let ((ret (sp-multicast (con-mbox con) service-type g mess-type (length mess) s)))
      (if (< ret 0)
	  (print-error-msg ret)))))

(defmacro kill (con)
  `(let ((ret (sp-kill (con-mbox ,con))))
    (when (< ret 0)
      (free (conp-mbox ,con)))
    (setf ,con nil)))

(defun disconnect (con)
  (let ((ret (sp-disconnect (con-mbox con))))
    (if (< ret 0)
	(print-error-msg ret))))
(defmacro quit-con (con)
  `(progn (disconnect ,con)
	  (free (conp-mbox ,con))
	  (setf ,con nil)))

(defun print-error-msg (code)
  (when (< code 0)
    (format out "ERROR ~a~%"
	    (case code
	      (-1 "Illegal spread")
	      (-2 "Could not connect")
	      (-3 "Reject quota")
	      (-4 "Reject no name")
	      (-5 "Reject illegal name")
	      (-6 "Reject not unique")
	      (-7 "Reject version")
	      (-8 "Connection closed")
	      (-9 "reject auth")
	      (-10 "Illegal service")
	      (-11 "Illegal service")
	      (-12 "Illegal service")
	      (-13 "Illegal message")
	      (-14 "Illegal group")
	      (-15 "Buffer too short")
	      (-16 "Groups too short")
	      (-17 "Message too long")
	      (-18 "Net error on session")
	      (otherwise "this fuck up is beyond error messages")))))

