(in-package :cl-spread)

(defctype u32 :unsigned-int)


(defvar num-sent)
(defvar previous-len)
(defvar num-groups)
(defvar +max-messlen+ 102400)
(defvar +max-vssets+ 10)
(defvar +max-members+ 100)
(defvar to-exit 0)
(defun print-menu ()
	(format out "~%")
	(format out "==========~%")
	(format out "User Menu:~%")
	(format out "----------~%")
	(format out "~%")
	(format out "~aj <group> -- join a group~%" #\tab)
	(format out "~al <group> -- leave a group~%" #\tab)
	(format out "~%")
	(format out "~as <group> -- send a message~%" #\tab)
	(format out "~ab <group> -- send a burst of messages~%" #\tab)
	(format out "~%")
	(format out "~aq -- quit~%" #\tab)
	(force-output out))
	

(let ((user (alloc :char 80))
      (spread-name (alloc :char 80))
      (private-group (alloc :char 1000))
      (mbox (alloc :int)))
  (dotimes (x 4)
    (setf (mem-aref user :char x) (char-code (aref "user" x))))
  (setf (mem-aref user :char 4) 0)
  (dotimes (x 14)
    (setf (mem-aref spread-name :char x) (char-code (aref "4803@localhost" x))))
  (setf (mem-aref spread-name :char 14) 0)
    

  (defun bye ()
    (format out "~%bye~%")
    (sp-disconnect (ref-int mbox)))
  
  (defun user-command ()
    (let ((command)
	  (ret)
	  (group))
      (setf command (read-line))
      (let ((lst (find-words command)))
	(setf group (cadr lst))
	(with-foreign-string (str (if group group ""))
	  (case (aref command 0)
	    (#\j 
	     (cond ((< (length group) 1)
		    (format out "invalid group~%"))
		   (t (setf ret (sp-join (ref-int mbox) str))
		      (if (< ret 1)
			  (sp-error ret)))))
	    (#\l (if (< (length group) 1)
		     (format out "invalid group~%"))
		 (setf ret (sp-leave (ref-int mbox) str))
		 (if (< ret 0) (sp-error ret)))
	    (#\r (read-message))
	    (#\p (setf ret (sp-poll (ref-int mbox)))
		 (format out "Polling says ~a~%" ret))
					;(#\e (
	    (#\q (bye))
	    (otherwise (format out "Unknown commnad~%")
		       (print-menu))))
	(format out "~%User> ")
	(force-output out))))

  (defun read-message ()
    (let ((mess (alloc :char +max-messlen+))
	  (sender (alloc :char +max-group-name+))
	  (target-groups (make-c-array :char `(,+max-members+ ,+max-group-name+)))
	  (memb-info (alloc 'membership-info))
	  (vssets (alloc 'vs-set-info +max-vssets+))
	  (my-vsset-index (alloc :uint))
	  (num-vs-sets)
	  (members (make-c-array :char `(,+max-members+ ,+max-group-name+)))
	  (num-groups (alloc :int))
	  (service-type (alloc :int))
	  (mess-type (alloc :int16))
	  (endian-missmatch (alloc :int))
	  (ret))
      (setf (ref-int service-type) 0)
      (setf ret (sp-receive (ref-int mbox) service-type sender 100 num-groups target-groups
			    mess-type endian-missmatch +max-messlen+ mess))
      (format out "~%============================~%")
      (if (< ret 0)
	  (when (or (= ret +groups-too-short+) (= ret +buffer-too-short+))
	    (format out "~%========Buffers or Groups too Short=======~%")
	    (setf (ref-int service-type) +drop-recv+
		  ret (sp-receive mbox service-type sender +max-members+ num-groups target-groups
				  mess-type endian-missmatch +max-messlen+ mess))))
      (when (< ret 0)
	(when (zerop to-exit)
	  (sp-error ret)
	  (format out "~%============================~%~%Bye~%"))
	(quit 0))
      (cond ((regular-messp (ref-int service-type))
	     (setf (mem-aref mess :char ret) 0)
	     (let ((st (ref-int service-type)))
	       (format out "~a"
		       (cond ((unreliable-messp st) "received UNRELIABLE ")
			     ((reliable-messp st) "received RELIABLE ")
			     ((fifo-messp st) "received FIFO ")
			     ((causal-messp st) "received CAUSAL ")
			     ((agreed-messp st) "received  AGREED ")
			     ((safe-messp st) "received  SAFE ")
			     (t (format out "~a, of type ~a, (endian ~a) to ~a groups~%(~a bytes): ~a~%"
					(foreign-string-to-lisp sender) (ref-int mess-type)
					(ref-int endian-missmatch) (ref-int num-groups)
					ret (foreign-string-to-lisp mess)) "")))))
	    ((membership-messp (ref-int service-type))
	     (setf ret (sp-get-memb-info mess (ref-int service-type) memb-info))
	     (when (< ret 0)
	       (format out "BUG: membership message does not have valid body~%")
	       (sp-error ret)
	       (quit 1))
	     (when (reg-memb-messp (ref-int service-type))
	       (format out "Received REGULAR membership for group ~a with ~a members, where I am momber ~a:~%"
		       (foreign-string-to-lisp sender) (ref-int num-groups) (ref-int mess-type))
	       (dotimes (x (ref-int num-groups))
		 (format out "~a~a~%" #\tab (foreign-string-to-lisp (mem-aref target-groups :pointer x))))
	       (format out "grp id is ~a ~a ~a~%"
		       (mem-aref (membership-info.gid.id memb-info) :int 0)
		       (mem-aref (membership-info.gid.id memb-info) :int 1)
		       (mem-aref (membership-info.gid.id memb-info) :int 2))
	       (cond ((caused-join-messp (ref-int service-type))
		      (format out "Due to the JOIN of ~a~%"
			      (foreign-string-to-lisp (membership-info.changed-member memb-info))))
		     ((caused-leave-messp (ref-int service-type))
		      (format out "Due to the LEAVE ~a~%"
			      (foreign-string-to-lisp (membership-info.changed-member memb-info))))
		     ((caused-disconnect-messp (ref-int service-type))
		      (format out "Due to the DISCONNECT of ~a~%"
			      (foreign-string-to-lisp (membership-info.changed-member memb-info))))
		     ((caused-network-messp (ref-int service-type))
		      (format out "Due to NETWORK change with ~a VS sets~%"
			      (ref-uint (membership-info.num-vs-sets memb-info)))
		      (setf num-vs-sets (sp-get-vs-sets-info mess vssets +max-vssets+ my-vsset-index))
		      (when (< num-vs-sets 0)
			(format out "BUG: membership message has more than ~a vs sets. Recompile with larger MAX_VSSETS~%" +max-vssets+)
			(sp-error num-vs-sets)
			(quit 1))
		      (dotimes (i num-vs-sets)
			(format out "~a VS set ~a has ~a members~%"
				(if (= i (ref-uint my-vsset-index)) "LOCAL" "OTHER")
				i (vs-set-info.num-members (mem-aref vssets 'vs-set-info i)))
			(setf ret (sp-get-vs-set-members mess (mem-aptr vssets 'vs-set-info)
							 members +max-members+))
			(when (< ret 0)
			  (format out "VS Set has more than ~a members." +max-members+)
			  (sp-error ret)
			  (quit 1))
			(dotimes (j (vs-set-info.num-members (mem-aptr vssets 'vs-set-info i)))
			  (format out "~a~a~%" #\tab (foreign-string-to-lisp (mem-aref members :pointer j))))))
		     ((transition-messp (ref-int service-type))
		      (format out "received TRANSITIONAL membership for group ~a~%" (foreign-string-to-lisp sender)))
		     ((caused-leave-messp (ref-int service-type))
		      (format out "received membership mssage that left group ~a~%" (foreign-string-to-lisp sender)))
		     (t (format out "received incorrectly membership message of type ~x~%" (ref-int service-type))))))
	    ((reject-messp (ref-int service-type))
	     (format out "REJECTED message from ~a, of servicetype ~x messtype ~a (endian ~a) to ~a groups~%(~a bytes): ~a~%" (foreign-string-to-lisp sender) (ref-int service-type) (ref-int mess-type) (ref-int endian-missmatch)
		     (ref-int num-groups) ret (foreign-string-to-lisp mess)))
	    (t (format out "received message of unknown message type ~x with ret ~a~%"
		       (ref-int service-type) ret))
	    (format out "~%User> ")
	    (force-output)
	    (free mess sender target-groups memb-info vssets my-vsset-index members num-groups service-type mess-type endian-missmatch))))
				  
      
      
      


      (defun main ()
	(make-struct 'test-timeout 'sp-time :vals '((sec 5) (usec 0)))
	(let ((ret))
	  (setf ret (sp-connect-timeout spread-name user 0 1 mbox private-group (get-pointer 'test-timeout)))
	  (format out "ret ~a~%" ret)
	  (when (/= ret +accept-session+)
	    (sp-error ret)
	    (bye)
	    (return-from main 1))
	  (format out "User: connected to ~a with private group ~a~%"
		  (foreign-string-to-lisp spread-name)
		  (foreign-string-to-lisp private-group))
	  (print-menu)
	  (format out "~%User> ")
	  (force-output out)
	  (setf num-sent 0)
	  (loop (user-command)))))
	  ;(free user spread-name private-group mbox)
	  ;(free-pointer 'test-timeout)
	  ;0)))
